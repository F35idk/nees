use super::{apu, cpu, ppu};
#[macro_use]
use super::super::util;
use super::{CpuAddressBus, PpuAddressBus};

// NOTE: ines header tells whether need care abt. nametable mirroring selection
// NOTE: currently only care about mapper 004

struct Mmc3CpuAddressBus {
    apu: apu::Apu,
    ppu: ppu::Ppu,
    ppu_memory: Mmc3PpuAddressBus,

    internal_mem: [u8; 0x2000],
    prg_ram: [u8; 0x2000],
    // up to 256 banks
    chr_banks: Box<[[u8; 0x400]]>,
    // up to 64 banks
    prg_banks: Box<[[u8; 0x2000]]>,
    // bank registers r0-r7
    r: [u8; 8],

    bools: Mmc3CpuBools::BoolField,

    // bank select register (at even addresses at 0x8000-0x9ffe)
    // TODO: remove
    bank_select: u8,
}

boolfield!(Mmc3CpuBools<u8>(
    // true means 0x8000-0x9fff is fixed to the second to last bank
    // and 0xc000-0xdfff is switchable, false means the opposite
    prg_banks_swapped: 1,
    hor_mirroring: 2,
    no_mirroring: 3,
    prg_ram_enable: 4,
    prg_ram_protect: 5,
    irq_reload: 6,
    irq_enable: 7,
));

struct Mmc3PpuAddressBus {
    // TODO: ..
}

impl PpuAddressBus for Mmc3PpuAddressBus {
    fn read(&self, addr: u16) -> u8 {
        unimplemented!()
    }

    fn write(&mut self, addr: u16, val: u8) {
        unimplemented!()
    }

    fn get_pattern_tables(&self) -> &[u8; 0x2000] {
        unimplemented!()
    }
}

impl Mmc3CpuAddressBus {
    pub fn new(n_prg_banks: u8, chr_size_kb: u8) -> Self {
        assert!(n_prg_banks.is_power_of_two());
        assert!(chr_size_kb.is_power_of_two());

        let chr_banks = {
            let slice = vec![0u8; 0x400 * chr_size_kb as usize].into_boxed_slice();
            let raw = Box::into_raw(slice) as *mut [[u8; 0x400]];

            unsafe { Box::from_raw(raw) }
        };

        let prg_banks = {
            let slice = vec![0u8; 0x2000 * n_prg_banks as usize].into_boxed_slice();
            let raw = Box::into_raw(slice) as *mut [[u8; 0x2000]];

            unsafe { Box::from_raw(raw) }
        };

        unimplemented!()
    }

    fn is_swap_prg_windows(&self) -> bool {
        (self.bank_select & 0b100_0000) != 0
    }

    fn set_swap_prg_windows(&mut self, swap: bool) {
        self.bank_select = (self.bank_select & 0b100_0000) | ((swap as u8) << 6);
    }

    // fn is_ppu_a12(&self) -> bool {
    //     (self.bank_select & 0b1000_0000) != 0
    // }

    // fn set_ppu_a12(&mut self, a12: bool) {
    //     self.bank_select = (self.bank_select & 0b1000_0000) | ((a12 as u8) << 7);
    // }
}

impl CpuAddressBus for Mmc3CpuAddressBus {
    fn read(&mut self, mut addr: u16, cpu: &mut cpu::Cpu) -> u8 {
        // internal ram
        if super::is_0_to_1fff(addr) {
            addr &= !0b1_1000_0000_0000;

            return unsafe { *self.internal_mem.get(addr as usize).unwrap() };
        }

        // ppu registers
        if super::is_2000_to_3fff(addr) {
            self.ppu.catch_up(cpu, &mut self.ppu_memory);
            addr &= 0b111;
            return self
                .ppu
                .read_register_by_index(addr as u8, &self.ppu_memory);
        }

        // prg ram
        if super::is_6000_to_7fff(addr) {
            addr &= !0b110_0000_0000_0000;
            return unsafe { *self.prg_ram.get(addr as usize).unwrap() };
        }

        // switchable or fixed bank
        if super::is_8000_to_9fff(addr) {
            let bank = if self.bools.prg_banks_swapped.get() {
                // the second to last bank
                &self.prg_banks[self.prg_banks.len() - 3]
            } else {
                let n_banks = self.prg_banks.len() as u8;
                // the bank pointed to by r6 (modulo the number of banks)
                &self.prg_banks[(self.r[6] & (n_banks - 1)) as usize]
            };

            addr &= !0b1110_0000_0000_0000;
            return unsafe { *bank.get(addr as usize).unwrap() };
        }

        // switchable bank
        if super::is_8000_to_9fff(addr) {
            let n_banks = self.prg_banks.len() as u8;
            let bank = &self.prg_banks[(self.r[7] & (n_banks - 1)) as usize];
            addr &= !0b1110_0000_0000_0000;
            return unsafe { *bank.get(addr as usize).unwrap() };
        }

        0
    }

    fn write(&mut self, addr: u16, val: u8, cpu: &mut cpu::Cpu) {}

    fn get_ppu(&mut self) -> (&mut ppu::Ppu, &mut dyn PpuAddressBus) {
        (&mut self.ppu, &mut self.ppu_memory)
    }

    fn get_apu(&mut self) -> &mut apu::Apu {
        &mut self.apu
    }
}

#[test]
fn mess() {
    let mut addr = 0x7fff;
    addr &= !0b110_0000_0000_0000;
    assert_eq!(addr, 0x1fff);

    let addr = 0x8fff;
    assert!(super::is_8000_to_9fff(addr));

    let mut addr = 0x7fff;
    addr &= !0b110_0000_0000_0000;
    assert_eq!(addr, 0x1fff);
    // ..
}

// prg windows:
//   swappable:
//     0x8000-0x9fff / 0xc000-0xdfff (depending on mode)
//     0xa000-0xbfff
//   fixed:
//     0xc000-0xdfff / 0x8000-0x9fff (depending on mode)
//     0xe000-0xffff

// chr windows (all swappable):
// (? = 1 | 0, a12 may be inverted)
//   0x?000-0x?7FF: 2 KB
//   0x?800-0x?FFF: 2 KB
//   0x?000-0x?3FF: 1 KB
//   0x?400-0x?7FF: 1 KB
//   0x?800-0x?BFF: 1 KB
//   0x?C00-0x?FFF: 1 KB
